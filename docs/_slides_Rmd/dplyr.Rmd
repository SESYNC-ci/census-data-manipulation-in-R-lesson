---
# filter by NAICS
---

## Key dplyr functions

| Function    | Returns                                            |
|-------------+----------------------------------------------------|
| `filter`    | keep rows that staisfy conditions                  |
| `select`    | keep columns with matching names                   |
| `group_by`  | split data into groups by an existing factor       |
| `mutate`    | apply a transformation to existing [split] columns |
| `summarize` | summarize across rows [and combine split groups]   |

The table above presents the most commonly used functions in [dplyr](){:.rlib}, which we will demonstrate in turn, starting from the `cbp` data frame.
{:.notes}

===

## Subsetting

The cbp table includes character `NAICS` column. Of the 2 million observations, lets see how many observations are left when we keep only observations from the Health Care and Social Assistance sector.

```{r lib, message = FALSE, title = '{{ site.handouts[0] }}'}
library(dplyr)
```

===

```{r filter, title = '{{ site.handouts[0] }}'}
cbp_health_care <- filter(
  cbp,
  NAICS == '62----')
```

===

That may not be what we wanted, because it's the aggregated data.

```{r view_filter}
str(cbp_health_care)
```

===

```{r filter_more, title = '{{ site.handouts[0] }}', warning = FALSE}
library(stringr)
cbp_health_care <- filter(
  cbp,
  str_detect(NAICS, '^62'),
  !is.na(as.integer(NAICS))
  )
```

Note that a logical "and" is implied when conditions are separated by commas.
(This is perhaps the main way in which `filter` differs from the base R `subset`
function.) Therefore, the example above is equivalent to `filter(cbp,
str_detect(NAICS, '^62') & !is.na(as.integer(NAICS)))`. A logical "or" must be
specified explicitly with the `|` operator.
{:.notes}

===

To keep particular columns of a data frame (rather than choosing rows) , use the `select` with arguments that match the column names.

```{r}
names(cbp)
```

===

One way to "match" is by including complete names, each one you want to keep:

```{r eval=FALSE}
select(cbp_health_care,
  FIPSTATE, FIPSCTY,
  NAICS,
  EMPFLAG, EMP_NF, EMP
)
```

===

Alternatively, we can use a "select helper"" to match patterns.

```{r select, title = '{{ site.handouts[0] }}'}
cbp_health_care <- select(cbp_health_care,
  starts_with('FIPS'),
  NAICS,
  starts_with('EMP')
)
```

===

```{r view_select}
str(cbp_health_care)
```

<!--
===

To complete this section, we sort the 1990 winter animals data by descending order of species name, then by ascending order of weight. Note that `arrange` assumes ascending order unless the variable name is enclosed by `desc()`.

```{r arrange, title = '{{ site.handouts[0] }}'}
sorted <- arrange(animals_1990_winter,
                  desc(species_id), weight)
```

```{r view_arrange}
head(sorted)
```
-->

===

## Exercise 2

Write code that returns the annual payroll data for the top level Construction sector ("23----").

[View solution](#solution-2)
{:.notes}
