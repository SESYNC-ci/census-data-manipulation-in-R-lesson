---
---

## Key data wrangling functions

| Function                         | Returns                                                                                                    |
|----------------------------------+------------------------------------------------------------------------------------------------------------|
| `filter(data, ...)`              | rows from *data* where any conditions in place of `...` hold                                               |
| `select(data, ...)`              | the columns of *data* named by variables in place of `...`                                                 |
| `arrange(data, ...)`             | *data* sorted by any variables in place of `...`                                                           |
| `mutate(data, %var% = %fun%)`    | a copy of *data* with additional *var* column defined by the output of function %fun%                      |
| `group_by(data, ...)`            | a copy of *data* with a grouping attribute based on all variables in `...`                                 |
| `summarize(data, %var% = %fun%)` | a data frame with %var% column that summarizes each group in *data* based on an aggregation function %fun% |

The table above presents the most commonly used functions in [dplyr](){:.rlib}, which we will demonstrate in turn, starting from the `animals` data frame.
{:.notes}

===

## Subsetting and sorting

After loading dplyr, we begin our analysis by extracting the survey observations for the first three months of 1990 with `filter`:

```{r filter, message=FALSE, title="{{ site.handouts }}"}
library(dplyr)
animals_1990_winter <- filter(animals,
			      year == 1990,
			      month %in% 1:3)
```

```{r view_filter}
str(animals_1990_winter)
```

Note that a logical "and" is implied when conditions are separated by commas. (This is perhaps the main way in which `filter` differs from the base R `subset` function.) Therefore, the example above is equivalent to `filter(animals, year == 1990 & month %in% 1:3)`. A logical "or" must be specified explicitly with the `|` operator.
{:.notes}

===

To choose particular columns (rather than the rows) of a data frame, we would call `select` with the name of the variables to retain.

```{r eval=FALSE}
select(animals_1990_winter,
       id, month, day, plot_id,
       species_id, sex, hindfoot_length, weight)
```

===


Alternatively, we can *exclude* a column by preceding its name with a minus sign. We use this option here to remove the redundant year column from *animals_1990_winter*:

```{r select, title="{{ site.handouts }}"}
animals_1990_winter <- select(animals_1990_winter, -year)
```

```{r view_select}
str(animals_1990_winter)
```

===

To complete this section, we sort the 1990 winter animals data by descending order of species name, then by ascending order of weight. Note that `arrange` assumes ascending order unless the variable name is enclosed by `desc()`.

```{r arrange, title="{{ site.handouts }}"}
sorted <- arrange(animals_1990_winter,
                  desc(species_id), weight)
```

```{r view_arrange}
head(sorted)
```

===

![]({{ site.baseurl }}/images/img_4185.jpg){:width="40%"}  
*Credit: [The Portal Project](https://portalproject.wordpress.com)*
{:.captioned}

### Exercise 2

Write code that returns the **id**, **sex** and **weight** of all surveyed individuals of *Reithrodontomys montanus* (RO).

[View solution](#solution-2)
{:.notes}

